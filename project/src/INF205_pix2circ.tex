\documentclass{article}


\usepackage{amsmath}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{float}

\title{Pixel to circles project}
\author{Mats Hoem Olsen, Katla Marie Mayer, Oda Johanne Matre Simensen}

\begin{document}
	\maketitle
	\tableofcontents
	\listofalgorithms
	\begin{abstract}
		We designed a code that converted a pixelated image to a vector based image using Moors contour algorithm, Harris corner detector, and Postscript\texttrademark. 
	\end{abstract}
	\newpage


	\section{Problem}
	As an input, a two-dimensional image or landscape is given by an a x a square of black-and-white pixels.

	Your code should create an approximation of this landscape by a set of superimposed circular disks. It should aim at the best possible accuracy for a given maximum number of circular disks that can be varied as part of the input. It should also be able to generate a lossless representation of the image/landscape using an unlimited number of circular disks.

	\subsection{assumptions}
	Assume that each pixel is b/w, that is either completely black (colour value 0) or completely white (colour value 1), not on a greyscale in between.

	Have your code produce a sequence of m circular discs 0 â‰¤ i < m, each with two coordinates of the centre, a radius, and a colour value ci, that compresses the pixel-based representation. The conversion back from the vector representation to the pixel representation could look as follows. For all pixel coordinates (0, 0) to (a-1, a-1): Initialize the pixel colour to black. Then, iteratively for all i from 0 to m-1, whenever the pixel coordinates are inside circle i, update the pixel colour to ci.

	Agreement between the original and the compressed version can be quantified by the fraction of pixels for which the algorithm above reconstructs the original colour value of the pixel correctly. In the case of a lossless compression, the two versions should agree for all pixels.

	You can deviate from the default recommendations; follow them just if you do not see any good reason not to.

	\section{Edge detector}
	The edge detector algorithm is composed of the following algortithm:
	\begin{algorithm}[H]
		\caption{Contour algorithm}
		\begin{algorithmic}
			\State $P_0 \gets$ first pixel of an shape
			\State $P_{-1} \gets$ previous pixel
			\State $P_n \gets P_0$
			\State $C$ is the contour of the shape
			\While{$P_n \neq P_0$}
				\State $P_{-1} \gets$ look anti-clockwise from $P_{-1}$
				\If{$P_{-1}$ is foreground}
					\State $C\gets P_{-1}$
					\State Swap label $P_{-1}$ and $P_n$
				\EndIf
			\EndWhile
			\State \Return C
		\end{algorithmic}
	\end{algorithm}
	This algorithm will trace the contour for one blob, but this will be used multiple times until we hit the lower right corner of the image. The foreground pixels will be stored in a coordinate structure that stores x, and y coordinates. 

	\section{Harris Corner detector}
	The Harris corner detector is used to find all the corners in an image (which in our case is the contour of one blob). The algorithm uses the eigen values from the first directional derivative matrix
	$$
		M = \left[\begin{matrix}
		I_x^2 & I_xI_y \\
		I_yI_x & I_y^2
\end{matrix}\right]
	$$
	After calculating the smallest eigen value for every point along the path it uses a simple threshold to determine if an eigen value is large enough to be considered a corner, or anything else. 
	The algorithm used is
	\begin{algorithm}
		\caption{Harris corner detector}
		\begin{algorithmic}
			\State $\lambda \gets \{\}$
			\State $C \gets \{\}$
			\ForAll{Points in picture}
				\State Calculate $I_x$ and $I_y$
				\State Make M matrix
				\State Find the smallest Eigen value
				\State $\lambda \gets$ eigen value
			\EndFor
			\ForAll{points in $\lambda$}
				\If{point > limit}
					\State $C \gets$ point
				\EndIf
			\EndFor
			\State \Return C
		\end{algorithmic}
	\end{algorithm}
	\section{Image viewer}
	To store the circles we have found in the image, we choose to use the language Postscript since it has simple enough syntax to export it, and convert it to other file formats that support vector graphics. The command we will be using is "arc fill". This command will take inn x,y coordinates, a radius, and angle of the arc. The "fill" command just uses watershed algorithm to fill inn the circle with black.

\end{document}
